\documentclass{math}

\usepackage{tikz}
\geometry{letterpaper, margin=0.8in}

\title{CSCI 251: Concepts of Parallel and Distributed Systems}
\author{Alvin Lin}
\date{September 2017 - December 2017}

\begin{document}

\maketitle

\section*{Project 3}

\subsection*{Introduction}
This project involved a robot simulation in which the objective of the robots
was to surround a target at an unknown location. Given that there was no global
coordinator and each robot acted independently, this was accomplished by having
the robots communicate their search space to each other to efficiently search
the grid for the location of the target.

\subsection*{Outline}
This simulation runs the robots in two phases, a search phase where they perform
a clustered search for the target block, and a convergence phase where they
converge onto the block to surround it. \par
During the search phase, the robots each independently use breadth first search
to find the closest unsearched square. After proceeding there, they mark their
respective surrounding squares as searched and communicate it via multicast to
the other robots. (As an implementation specific detail, this was accomplished
with a shared memory space). Each robot acquires a mutex (shared among all of
them) to ensure data stability before computing the next location it moves to.
The first robot to locate the target block broadcasts it to all the other
robots. \par
During the convergence phase, the target block location has been broadcasted to
all the robots. Each robot will independently use breadth first search again to
converge towards a location whose Euclidean distance to the block is smallest.
At this point, if the robot determines that it is as close as it can possibly
be to the block, then it will declare itself as done. When all robots have
declared themselves as done, the simulation ends. Because of the nature of the
search algorithm, the robots converge onto the target on a first-come
first-serve basis, and do not need to communicate or agree on where they will
go.

\subsubsection*{Single Robot}
\begin{center}
  \begin{tikzpicture}
    \draw[->,very thick] (-4,2) -- (0,2) node[pos=0.5,above]
      {acquire mutex lock};
    \draw (0,0) rectangle (8,4) node[pos=0.5,yshift=2.5cm] {within mutex lock};
    \draw[->,very thick] (8,2) -- (12,2) node[pos=0.5,above]
      {release mutex lock};
    \draw[fill] (0.2,2) circle (0.1cm);
    \draw[<-,very thick] (0.1,1.9) -- (-1,0.5) node[left]
      {\scriptsize{branch if target is known}};
    \draw[->] (0.2,2) -- (2,0.5) node[pos=0.5,right]
      {\scriptsize{BFS for unsearched space}};
    \draw[dashed,->] (2.1,0.5) -- (2.1,-1) node[below] {multicast};
    \draw[->] (0.2,2) -- (2,3.5) node[pos=0.5,right]
      {\scriptsize{BFS for target}};
    \draw[->] (2.2,0.5) -- (6,0.5) -- (6.5,1.9);
    \draw[->] (2.2,3.5) -- (6,3.5) -- (6.5,2.1);
    \draw[->] (6.6,2) -- (7.9,2) node[pos=0.5,above] {\scriptsize{update}};
  \end{tikzpicture}
\end{center}

\subsubsection*{A Single Update Cycle}
\begin{center}
  \begin{tikzpicture}
    \draw[->] (0,4) -- (3,4) node[pos=0.5,above]
      {\scriptsize{update cycle begins}};
    \foreach \y in {0,2,6,8} {
      \draw[->] (3.1,4) -- (5,\y);
      \draw (5.1,\y-0.5) rectangle (8,\y+0.5);
      \draw (8.1,\y) -- (10,4);
    }
    \draw[->] (10,4) -- (13,4) node[pos=0.5,above]
      {\scriptsize{update cycle ends}};
    \node[right] at (5.2,0) {Robot \( k \)};
    \node[right] at (5.2,2) {Robot \( k-1 \)};
    \node[right] at (5.2,4) {\large{\( \vdots \)}};
    \node[right] at (5.2,6) {Robot 2};
    \node[right] at (5.2,8) {Robot 1};
    \draw[dashed,->,very thick] (5.5,7.5) .. controls (6,4) .. (5.5,0.5);
    \draw[dashed,->,very thick] (5.5,7.5) .. controls (6.5,5) .. (6.5,2.5)
      node[pos=0.6,right] {multicast};
    \draw[dashed,->,very thick] (5.5,7.5) -- (7.5,6.5);
    \node[left] at (4.5,7) {\scriptsize{wait for mutex}};
  \end{tikzpicture}
\end{center}

During the update cycle, each robot maintains whether or not it has updated
during that cycle. If it has already updated, then it will not update until
the next update cycle begins. This ensures that each robot updates once during
each cycle. Since the state of the grid is stable at the end of each update
cycle, we delegate the task of drawing the grid to the output to the last robot
to update.

\end{document}
