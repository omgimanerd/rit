\documentclass{math}

\usepackage{forest}

\title{Introduction to Computer Science Theory}
\author{Alvin Lin}
\date{August 2017 - December 2017}

\begin{document}

\maketitle

\section*{Context Free Grammars}
A \textbf{context-free grammar} is a 4-tuple \( G = (V,\Sigma,R,S) \) where
\begin{itemize}
  \item \( V \) is a finite set of variables (non-terminal symbols).
  \item \( \Sigma \) is a finite set of terminal symbols (terminals).
  \item \( R \) is the finite set of grammar rules (productions). Each rule is
  of the form \( A\to\alpha \), where \( A\in V \) and
  \( \alpha\in(V\cup\Sigma)^* \).
  \item \( S\in V \) is the start symbol.
\end{itemize}
Here is a CFG that generates \( \{a^ib^i\mid i\ge0\} \):
\( G = (V,\Sigma,R,S) \) where:
\begin{itemize}
  \item \( V = \{S\} \)
  \item \( \Sigma = \{a,b\} \)
  \item \( R = \{S\to\epsilon,S\to aSb\} \)
\end{itemize}
\( aaabbb \) is in the language generated by \( G \) because you can transform
\( S \) into \( aaabbb \) by a finite number of applications of the rules from
\( R \).
\[ S\Rightarrow aSb\Rightarrow aaSbb\Rightarrow aaabbb \]
This is called a derivation of \( aaabbb \). Notationally, we will use \( \to \)
in the rules and \( \Rightarrow \) in the application of the rule in a string.

\subsection*{Definition}
\( L(G) \) (the language generated by \( G \)) is defined as \( \{x\in\Sigma^*
\mid S\stackrel{*}{=}_{G}x\} \). A language \( L \) is a context free language
(CFL) if there is a context-free grammar \( G \) such that \( L = L(G) \).
These grammars are called context-free because if \( A\to\gamma \) is a rule,
then you can apply the rule to string \( \alpha A\beta \), no matter what
\( \alpha \) and \( \beta \) are.

\subsubsection*{Example}
\( \{x\in\{a,b\}^*\mid x\text{ is a palindrome}\} \). \( G = (V,\Sigma,R,S) \):
\begin{itemize}
  \item \( V = \{S\} \)
  \item \( \Sigma = \{a,b\} \)
  \item \( R = \{ S\to\epsilon, S\to aSa, S\to bSb, S\to a, S\to b\} \)
\end{itemize}

\subsection*{Derivation Trees}
To specify what it means for two derivations to essentially be the same, we will
look at derivation trees. A derivation tree is a tree representation of a
derivation. Two derivations are essentially the same if and only if they
correspond to the same derivation tree. Consider the grammar \( G =
(G,\Sigma,R,S) \)
\begin{itemize}
  \item \( V = \{EXPR,TERM,FACTOR\} \)
  \item \( \Sigma = \{a,+,x,(,)\} \)
  \item \( R = \{ \)
  \begin{align*}
    EXPR&\to EXPR+TERM \\
    EXPR&\to TERM \\
    TERM&\to TERM\times FACTOR \\
    TERM&\to FACTOR \\
    FACTOR&\to (EXPR) \\
    FACTOR&\to a
  \end{align*}
  \( \} \)
  \item \( S = EXPR \)
\end{itemize}
The parse tree for the string \( a+a\times a \) is as follows:
\begin{center}
  \begin{forest}
    [ EXPR
      [ EXPR
        [ TERM
          [ FACTOR
            [ a ]
          ]
        ]
      ]
      [+]
      [
        [ TERM
          [ TERM
            [ FACTOR
              [ a ]
            ]
          ]
        ]
        [ \( \times \) ]
        [ FACTOR
          [ a ]
        ]
      ]
    ]
  \end{forest}
\end{center}

\subsection*{Ambiguity}
A context-free grammar \( G \) is ambiguous if and only if there is a string
\( x\in L(G) \) such that \( x \) has two or more distinct derivation trees.
\( x+x\times x \) is ambiguous since order of precedence is ambiguous. Some
languages are inherently ambiguous, but we are often able to find unambiguous
grammars for certain context-free languages.

\subsection*{Machines for Context-Free Languages}
Regular languages are exactly the languages accepted by finite automatons.
Analogously, context-free languages are exactly the languages accepted by
pushdown automaton.

\subsection*{Pushdown Automata}
A pushdown automaton is the equivalent of adding a stack to a nondeterministic
finite automaton. Each move of a pushdown automaton will be determined by the
current state, the next input symbol, and the symbol on top of the stack. Each
move consists of changing the state and either popping off the top character of
the stack or pushing another character onto the stack. If the stack is empty,
the pushdown automaton reaches a stuck state if it attempts to read. Pushdown
automata start in an initial state and have a special start symbol on the
stack. They accept a string \( x \) if and only if the pushdown automaton can
get from the initial state to an accepting state after processing all of
\( x \). A pushdown automaton is a sextuple \( (Q,\Sigma,\Gamma,\delta,q_0,F) \)
where:
\begin{itemize}
  \item \( Q \) is a finite set of states.
  \item \( \Sigma \) is a finite set called the input alphabet.
  \item \( \Gamma \) is a finite set called the stack alphabet.
  \item \( \delta \) is the transition function from \( Q\times\Sigma_{\epsilon}
  \times\Gamma_{\epsilon} \) to \( 2^{Q\times\Gamma_{\epsilon}} \).
  \item \( q_0\in Q \) is the initial state.
  \item \( F\subseteq Q \) is the set of accepting states.
\end{itemize}
A pushdown automaton \( M = (Q,\Sigma,\Gamma,\delta,q_0,F) \) accepts
\( w = w_1w_2\dots w_n \) where \( w_1w_2\dots w_n\in\Sigma_{\epsilon} \), if
there is a sequence of states \( r_0,r_1,\dots,r_n\in Q \) and strings
\( s_0,s_1,\dots,s_n\in\Gamma^* \) such that:
\begin{itemize}
  \item \( r_0 = q_0 \) and \( s_0 = \epsilon \)
  \item \( \forall{i}\in\{0,\dots,n-1\}((r_{i+1},b)\in\delta(r_i,w_{i+1},a)) \)
  where \( s_i = at \) and \( s_{i+1} = bt \) for \( a,b\in\Gamma_{\epsilon} \)
  and \( t\in\Gamma^* \).
  \item \( r_n\in F \)
\end{itemize}

\begin{center}
  You can find all my notes at \url{http://omgimanerd.tech/notes}. If you have
  any questions, comments, or concerns, please contact me at
  alvin@omgimanerd.tech
\end{center}

\end{document}
