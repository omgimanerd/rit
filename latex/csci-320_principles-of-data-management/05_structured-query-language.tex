\documentclass{math}

\usepackage{listings}

\title{Principles of Data Management}
\author{Alvin Lin}
\date{August 2018 - December 2018}

\begin{document}

\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true}
\maketitle

\section*{Structured Query Language}
Structured Query Language (SQL) was created at IBM in the 80s:
\begin{itemize}
  \item SQL-86 (first standard)
  \item SQL-89
  \item SQL-92 (what all SQL compliant DBs use)
  \item SQL-1999
  \item SQL-2003
\end{itemize}
SQL is a commercial language that is intended to be a data manipulation
language, but supports features of data definition languages. It supports the
following features:
\begin{itemize}
  \item Schema
  \item Domain
  \item Integrity Constraints
  \item Indicies
  \item Security
  \item Physical Storage
\end{itemize}

\subsection*{Domain Types}
\begin{itemize}
  \item \texttt{char(n)} - n number of characters
  \item \texttt{int} - numbers
  \item \texttt{smallint} - smaller value number
  \item \texttt{numeric(p,d)} - precision decimal
  \item \texttt{real,double,float} - ``infinite'' precision decimals
  \item \texttt{varchar(n)} - variable length characters
\end{itemize}

\subsection*{Create Table}
\begin{lstlisting}
  create table r (A1 D1, A2 D2,\dots,An Dn) (integrity constraints)}
\end{lstlisting}
Example:
\begin{lstlisting}
  create table dog(
    ID int,
    Name varchar(20),
    Salary numeric(8,2),
    goodboy smallint
  )
\end{lstlisting}
Integrity Constraints:
\begin{itemize}
  \item Not null
  \item Primary key
  \item Foreign key references
\end{itemize}
Example:
\begin{lstlisting}
  create table p(
    ID int,
    Name varchar(4) not null,
    DOB varchar(10),
    dog_id int,
    primary key(ID, Name),
    foreign key(dog_id) references dog(ID)
  )
\end{lstlisting}

\subsection*{CRUD}
\begin{lstlisting}
  insert into r values (v1,v2,vn)
  insert into dog values (1,"cat",10.00,0)
  delete from dog
  drop table r
  alter table dog add iscat int not null default 0
  alter table dog drop iscat
\end{lstlisting}

\subsection*{Select}
\begin{lstlisting}
  select a1,a2,a3,an from r1,r2,rn where predicate
  select name from dog
  select distinct name from dog
  select all name from dog
  select "joe" as name
  select name,"lab" as breed from dog
  select * from dog
\end{lstlisting}
Explicitly specify what attributes to return, \texttt{SELECT *} should be
avoided with the exception of manually viewing data.
\begin{lstlisting}
  select id,name,salary as pay from dog where salary > 80000
\end{lstlisting}
The \texttt{where} keyword allows for conditions by which we can filter the
returned rows. We can specify modifications to the returned attribute and use
boolean conditions to create compound conditionals.
\begin{lstlisting}
  select id,name,salary/26 as pay from dog where salary > 80000 and breed="lab"
\end{lstlisting}
The \texttt{between} modifier allows us to select a range as a predicate.
\begin{lstlisting}
  select * from dog where age between 6 and 9
\end{lstlisting}
Selecting from multiple tables using \texttt{SELECT *} returns a Cartesian
product.
\begin{lstlisting}
  select * from dog,cat
\end{lstlisting}
This is not particularly useful, it is much more useful to use a predicate to
match the data.
\begin{lstlisting}
  select * from dog,cat where dog.name = cat.name and dog.age = 4
  select * from dog as D, cat as C where D.age = C.age
\end{lstlisting}

\subsubsection*{Examples}
\begin{center}
  Table Dog: \\
  \begin{tabular}{|c|c|}
    \hline
    name & owner \\
    \hline
    Charlie & Snoopy \\
    Woodstock & Snoopy \\
    Lucy & Ricky \\
    Snoopy & Sam \\
    \hline
  \end{tabular}
\end{center}
Finding all the owners with dogs named Woodstock:
\begin{lstlisting}
  select d2.owner from dog where name = "woodstock"
\end{lstlisting}
Finding all the dogs owned by Snoopy:
\begin{lstlisting}
  select name from dog where owner = "snoopy"
\end{lstlisting}
Selecting the owner's owner of Charlie:
\begin{lstlisting}
  select owner from dog d1, dog d2 where d1.name = "charlie" and
      d1.owner = d2.name
\end{lstlisting}

\subsection*{String Operations}
The percent sign (\%) is used for partial substring matches while the
underscore (\_) is used for single character matches.
\begin{lstlisting}
  select * from dog where name like "%py"
  select * from dog where name like 'Sn\'' escape '\'
\end{lstlisting}
Concatenation is expressed with double pipes (\textbar\textbar).
\begin{lstlisting}
  select * from fname||lname like "%foo"
\end{lstlisting}

\subsection*{Ordering}
The \texttt{order by} keyword allows for queries to be sorted. Specifying more
than one sort option allows for sorting by multiple fields.
\begin{lstlisting}
  select name,lname from dog order by name asc
  select name,lname from dog order by name,lname desc
  select name,lname from dog order by name desc,lname
\end{lstlisting}

\subsection*{Set Operations}
Set operation keywords are valid in SQL.
\begin{lstlisting}
  (select name from dog) union (select name from cat)
  (select name from dog) intersect (select name from cat)
  (select name from dog) except (select name from cat)
\end{lstlisting}

\begin{center}
  You can find all my notes at \url{http://omgimanerd.tech/notes}. If you have
  any questions, comments, or concerns, please contact me at
  alvin@omgimanerd.tech
\end{center}

\end{document}
