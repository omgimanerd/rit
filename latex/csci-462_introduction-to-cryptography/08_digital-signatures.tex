\documentclass{math}

\title{Introduction to Cryptography}
\author{Alvin Lin}
\date{January 2018 - May 2018}

\begin{document}

\maketitle

\section*{Digital Signatures}
Suppose Alice orders a coffee maker from Bob's website. After seeing the coffee
maker, Alice states that she has never ordered it. How can Bob prove towards
a judge that Alice has never ordered a pink car? Symmetric cryptography fails
because both Alice and Bob can be malicious. This can only be achieved with
public key cryptography. The straightforward use of public key encryption
provides \textbf{confidentiality} but not \textbf{authentication}, however
public key cryptography can be used to provide authentication.

\subsection*{Authentication}
For a given message \( X \), a digital signature is appended to the message
just like a conventional signature. Only the person with the private key should
be able to generate the signature. The signature must change for every document
and is generated as a function with the message \( X \) and the private key
as input. The public key and the message \( X \) are the inputs to the
verification function. This provides authentication since only the holder of the
private key would have been able to provide that signature.
\par To provide both confidentiality and authentication, Alice can encrypt
the message \( M \) first using its private key which provides a digital
signature, and then using Bob's public key, which provides confidentiality.
The disadvantage is that the public key algorithm must be exercised four times
during each communication.

\subsection*{Goals of Digital Signatures}
\begin{enumerate}
  \item Confidentiality: Information is kept secret from unauthorized parties.
  \item Integrity: Ensures that a message has not been modified in transit.
  \item Message Authentication: Ensures that the sender of a message is
  authentic, also known as data origin authentication.
  \item Non-repudiation: Ensures that the sender of a message cannot deny the
  creation of the message.
\end{enumerate}
Additional goals of a secure system:
\begin{enumerate}
  \item Identification/entity authentication: Establishing and verifying the
  identity of an entity, whether it be a person, a computer, or a credit card.
  \item Access control: Restricting access to resources only to privileged
  entities.
  \item Availability: Providing readily available access to the system.
  \item Auditing: Capability of providing evidence about security relevant
  activities by keeping logs about certain events.
  \item Physical Security: Providing security against physical tampering.
  \item Anonymity: Providing protection against discovery and misuse of
  identity.
\end{enumerate}

\subsection*{Naive RSA Digital Signature Scheme}
To generate the private and public key, the same key generation scheme as RSA
is used. The signature is generated by encrypting the message \( X \) with the
private key \( K_{pr} \):
\[ S = signature_{kpr}(X) = X^d\mod n \]
The signature \( S \) is appended to the message \( X \). To verify the
signature, decrypt it with the public key \( K_{pub} \):
\[ X' = verification_{kpub}(S) = S^e\mod n \]
If the message \( X \) matches the decrypted signature \( X' \), then the
signature is valid. The security of the signature has the same constraints as
RSA encryption. \( n \) needs to be at least 1024 bits long and the signature
\( S \) needs to be at least 1024 bits long. Signature verification can be done
very quickly if a small number is chosen for the public key.
\par While effective, RSA digital signatures still have the problem of message
size and existential forgery. They only work if the message \( X \) is a number
less than \( n \). Because of the homomorphic property of RSA, if a hacker sees
two message signatures, they can compute the signature on the message without
knowing the private key. Additionally, suppose a hacker picks some signature
\( S \) and computes \( X = S^e\mod n \) using Bob's public key \( K_B = e \).
They can send the message \( X \) and signature \( S \) to impersonate Bob.
A person trying to verify the signature will compute \( X' = S^e\mod n \) and
find that \( X' = X \). While the message may not make sense, the signature
will match even though it did not come from Bob. Attackers can generate valid
message-signature pairs, but are only able to choose signatures and not the
message encoded. These problems can be combatted by using hash functions or
padding schemes to prevent attackers from generating valid key-signature pairs.

\subsection*{Public Key Algorithms}
\begin{center}
  \begin{tabular}{|c|c|c|c|}
    \hline
    Algorithm & Encryption/Decryption & Digital Signature & Key Exchange \\
    \hline
    RSA & Yes & Yes & Yes \\
    \hline
    Elliptic Curve & Yes & Yes & Yes \\
    \hline
    Diffie-Hellman & No & No & Yes \\
    \hline
    DSS & No & Yes & No \\
    \hline
  \end{tabular}
\end{center}

\subsection*{El Gamal Digital Signatures}
The security using El Gamal for digital signatures is based on the hardness of
the discrete logarithm problem. If Alice wants to sign a message, she needs to
generate a key:
\begin{enumerate}
  \item Alice chooses a large prime \( p \)
  \item Alice chooses a generator \( g \) for a large-order subgroup
  \( \Z_p^* \)
  \item Alice chooses a secret random number \( a \)
  \item Alice computes \( y = g^a\mod p \)
  \item Alice's public key is \( (p,g,y) \) and her private key is \( a \)
\end{enumerate}
She can then sign a message \( m \) using her private key:
\begin{enumerate}
  \item Alice chooses a secret random number \( k \) with \( gcd(k,p-1) = 1 \)
  \item Alice choose \( R = g^k\mod p \)
  \item Alice computes \( k^{-1} \) where \( k\cdot k^{-1}\equiv1\mod(p-1) \)
  \item Alice computes \( S = k^{-1}(Hash(X)-aR)\mod(p-1) \)
  \item Alice's signature for \( X \) is \( (R,S) \)
\end{enumerate}
Bob can then verify the signature \( (R,S) \) by using \( y \) from Alice's
public key to check if:
\[ g^{Hash(X)} = y^RR^S\mod p \]

\subsection*{Digital Signature Algorithm (DSA)}
The digital signature algorithm is based on the El Gamal signature scheme. It
was proposed by the National Institute of Standards and Technology and uses a
320 bit signature. Signature verification for this algorithm is significantly
slower compared to RSA. To generate a key:
\begin{enumerate}
  \item Generate a prime \( p \) with \( 2^{1023} < p < 2^{1024} \).
  \item Find a prime divisor \( q \) of \( p-1 \) with
  \( 2^{159} < q < 2^{160} \).
  \item Find an integer \( \alpha \) with \( order(\alpha) = q \).
  \item Choose a random integer \( d \) with \( 1 < d < q \).
  \item Compute \( \beta = a^d\mod p \).
  \item \( k_{pub} = (p,q,\alpha,\beta) \quad k_{pr} = d \)
\end{enumerate}
Given a message \( x \), a private key \( d \) and a the public key
\( (p,q,\alpha,\beta) \), generating a signature requires the following:
\begin{enumerate}
  \item Choose an integer as a random ephemeral key \( k_E \) with
  \( 0 < k_E < q \).
  \item Compute \( r \equiv (\alpha^{k_E}\mod p)\mod q \).
  \item Compute the signature \( s \equiv (SHA(x)+d\cdot r)(k_E)^{-1}\mod q \).
\end{enumerate}
The message signature consists of the pair \( (r,s) \) \( SHA(x) \) denotes the
hash function SHA-1 which computes a 160-bit fingerprint of message \( x \). To
verify the signature:
\begin{enumerate}
  \item Compute the auxiliary value \( w \equiv s^{-1}\mod q \).
  \item Compute the auxiliary value \( u_1 \equiv w\cdot SHA(x)\mod q \).
  \item Compute the auxiliary value \( u_2 \equiv w\cdot r\mod q \).
  \item Compute \( v \equiv (a^{u_1}\cdot\beta^{u_2}\mod p)\mod q \).
  \item If \( v \equiv r\mod q \), the signature is valid. Otherwise, it is
  invalid.
\end{enumerate}

\subsection*{Elliptic Curve Digital Signature Algorithm (ECDSA)}
The elliptic curve digital signature algorithm is based on elliptic curve
cryptography. Bit lengths in the range of 160-256 bits can be chosen to provide
security equivalent to 1024-3072 bit RSA. One signature consists of two points,
hence the signature is twice the used bit length. The shorter bit length of this
algorithm often results in shorter processing time. To generate a key using this
algorithm:
\begin{enumerate}
  \item We use an elliptic curve \( E \) with a modulus \( p \), coefficients
  \( a \) and \( b \), and a point \( A \) which generates a cyclic group of
  prime order \( q \).
  \item Choose a random integer \( d \) with \( 1 < d < q \).
  \item Compute \( B = dA \).
  \item \( k_{pub} = (p,a,b,q,A,B) \quad k_{pr} = d \)
\end{enumerate}
Generating a message signature is very similar to the DSA algorithm:
\begin{enumerate}
  \item Choose an integer as a random ephemeral key \( k_E \) with
  \( 1 < k_E < q \).
  \item Compute \( R = k_EA \)
  \item Let \( r = x_R \) from the message \( x \).
  \item Compute the signature \( s \equiv (SHA(x)+d\cdot r)(k_E)^{-1}\mod q \).
\end{enumerate}
To verify the signature:
\begin{enumerate}
  \item Compute the auxiliary value \( w\equiv s^{-1}\mod q \).
  \item Compute the auxiliary value \( u_1\equiv w\cdot SHA(x)\mod q \).
  \item Compute the auxiliary value \( u_2\equiv w\cdot r\mod q \).
  \item Compute \( P = u_1A+u_2B \).
  \item If \( x_P \equiv r\mod q \), the signature is valid. Otherwise, it is
  invalid.
\end{enumerate}

\subsection*{Digital Signature Standard (DSS)}
The federal government standards for digital signatures specifies a suite of
algorithms that can be used to generate a digital signature. The DSS permits
the usage of the three following digital signature algorithms:
\begin{enumerate}
  \item RSA
  \item Digital Signature Algorithm (DSA)
  \item Elliptic Curve Digital Signature Algorithm (ECDSA)
\end{enumerate}
For hash functions, the Digital Signature Standard permits the usage of SHA-1
or SHA-2 hash functions. With RSA, the standard mandates a 1024, 2048, or
3072-bit modulus \( n \) since the security is based on the hardness of integer
factorization. DSA uses a subgroup \( \Z_p^* \) with order \( q \) and is based
on the hardness of the discrete logarithm problem in \( \Z_p^* \), which
the standard allows to be either any of the following:
\begin{itemize}
  \item \( p = 1024, q = 160 \)
  \item \( p = 2048, q = 224 \)
  \item \( p = 2048, q = 256 \)
  \item \( p = 3072, q = 256 \)
\end{itemize}
For ECDSA, the standard recommends the curves P-192, P-224, P-256, P-384, P-521
with bit sizes \( q \). The security of ECDSA is based on the hardness of the
discrete logarithm problem in the elliptic curve group. It is worthwhile to note
that these systems allow messages to be authenticated, but not the public keys.
An attacker can still execute a man-in-the-middle attack if they can intercept
the public keys being exchanged.

\begin{center}
  You can find all my notes at \url{http://omgimanerd.tech/notes}. If you have
  any questions, comments, or concerns, please contact me at
  alvin@omgimanerd.tech
\end{center}

\end{document}
